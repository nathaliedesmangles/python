<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Solutions des ateliers :: 420-SN1-RE</title>
    <link>/solutions_ateliers/index.html</link>
    <description>02. Variables, types, entrées et fonctions&#xA;03. Structures conditionnelles&#xA;04. Boucles et débogage simple&#xA;06. Listes, chaines et visualisation des données&#xA;07. Dictionnaires&#xA;08. Tableaux NumPy et droite de régression linéaire&#xA;09. Manipulation des données avec Pandas&#xA;11. Fonctions personnalisées</description>
    <generator>Hugo</generator>
    <language>fr</language>
    <atom:link href="/solutions_ateliers/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title> Variables, types, entrées et fonction</title>
      <link>/solutions_ateliers/2_variables_types_entrees_fn/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/solutions_ateliers/2_variables_types_entrees_fn/index.html</guid>
      <description>Exercice #1 - Expérience en chimie # Constantes q_initiale = 400 # en mL t_minutes = 10 + 15/60 # conversion des 15 s en minutes =&gt; 10.25 minutes taux_evaporation = 25 # en mL/min # Formule : q(t) = 400 - 25 * t quantite_restante = q_initiale - taux_evaporation * t_minutes print(f&#34;Quantité restante après {t_minutes} minutes : {quantite_restante:.2f} mL.&#34;) Résultat attendu :&#xA;Quantité restante après 10.25 minutes : 143.75 mL. Exercice #2 - Calcul de la force gravitationnelle objet = input(&#34;Nom de l&#39;objet : &#34;) masse = float(input(&#34;Masse de l&#39;objet (en kg) : &#34;)) g = 9.8 # accélération gravitationnelle en m/s² force = masse * g print(f&#34;La force de la {objet} de {masse:.1f} Kg est de {force:.2f} N.&#34;) # Tests # Test 1 # &gt;&gt;&gt; balle, 2.5 # Test 2 # &gt;&gt;&gt; voiture, 1000.0 Résultats attendus :</description>
    </item>
    <item>
      <title> Structures conditionnelles</title>
      <link>/solutions_ateliers/3_struct_cond/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/solutions_ateliers/3_struct_cond/index.html</guid>
      <description># Demander les données à l&#39;utilisateur temperature = float(input(&#34;Température de l&#39;eau en °C : &#34;)) pression = float(input(&#34;Pression en atm (0.5, 1.0, 1.5 ou 2.0) : &#34;)) # Déterminer le point d’ébullition selon la pression if pression == 0.5: ebullition = 81 elif pression == 1.0: ebullition = 100 elif pression == 1.5: ebullition = 112 elif pression == 2.0: ebullition = 120 else: # Version améliorée: gestion d&#39;une pression invalide print(&#34;Pression invalide. Veuillez entrer 0.5, 1.0, 1.5 ou 2.0.&#34;) exit(0) # ou exit(), mais cela fera &#34;crasher&#34; Python (Kernel) # Déterminer l’état de l’eau if temperature &lt; 0: etat = &#34;solide&#34; description = &#34;L’eau est sous forme de glace.&#34; elif temperature &lt; ebullition: etat = &#34;liquide&#34; description = &#34;L’eau est liquide à cette température et pression.&#34; else: etat = &#34;gaz&#34; description = &#34;L’eau est sous forme de vapeur.&#34; # Affichage print(f&#34;État de l’eau : {etat}&#34;) print(description) Exemples de sorties Exemple 1 : Température de l&#39;eau en °C : 50&#xD;Pression en atm (0.5, 1.0, 1.5 ou 2.0) : 1.0&#xD;État de l’eau : liquide&#xD;L’eau est liquide à cette température et pression. Exemple 2 : Température de l&#39;eau en °C : 101&#xD;Pression en atm (0.5, 1.0, 1.5 ou 2.0) : 1.0&#xD;État de l’eau : gaz&#xD;L’eau est sous forme de vapeur. Exemple 3 : Température de l&#39;eau en °C : -5&#xD;Pression en atm (0.5, 1.0, 1.5 ou 2.0) : 2.0&#xD;État de l’eau : solide&#xD;L’eau est sous forme de glace. Version améliorée avec None # Demander la température temp = float(input(&#34;Température de l&#39;eau en °C : &#34;)) # Demander la pression pression = float(input(&#34;Pression en atm (0.5, 1.0, 1.5 ou 2.0) : &#34;)) # Déterminer le point d&#39;ébullition selon la pression ebullition = None # valeur par défaut si pression invalide if pression == 0.5: ebullition = 81 elif pression == 1.0: ebullition = 100 elif pression == 1.5: ebullition = 112 elif pression == 2.0: ebullition = 120 # Vérifier si la pression est valide if ebullition is None: print(&#34;Erreur : la pression doit être 0.5, 1.0, 1.5 ou 2.0 atm.&#34;) else: # Déterminer l&#39;état de l&#39;eau if temp &lt; 0: etat = &#34;solide&#34; message = &#34;L’eau est sous forme de glace.&#34; elif temp &lt; ebullition: etat = &#34;liquide&#34; message = &#34;L’eau est liquide à cette température et pression.&#34; else: etat = &#34;gaz&#34; message = &#34;L’eau est sous forme de vapeur.&#34; # Afficher le résultat print(f&#34;État de l’eau : {etat}&#34;) print(message) Exemple d’exécution avec None pour une pression invalide : Température de l&#39;eau en °C : 50&#xD;Pression en atm (0.5, 1.0, 1.5 ou 2.0) : 3&#xD;Erreur : la pression doit être 0.5, 1.0, 1.5 ou 2.0 atm.</description>
    </item>
    <item>
      <title> Boucles de débogage simple</title>
      <link>/solutions_ateliers/4_boucles_debogage/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/solutions_ateliers/4_boucles_debogage/index.html</guid>
      <description>Exercice 1 : Réaction chimique # Réaction : 1 mL de A + 2 mL de B a_dispo = int(input(&#34;Quantité de A disponible (en mL) : &#34;)) b_dispo = int(input(&#34;Quantité de B disponible (en mL) : &#34;)) nb_reactions = 0 while a_dispo &gt;= 1 and b_dispo &gt;= 2: a_dispo -= 1 b_dispo -= 2 nb_reactions += 1 print(&#34;La réaction a eu lieu&#34;, nb_reactions, &#34;fois.&#34;) print(&#34;Il reste&#34;, a_dispo, &#34;mL de A et&#34;, b_dispo, &#34;mL de B.&#34;) Exercice 2 : Détection de mutation nb_total = int(input(&#34;Combien d’échantillons vas-tu analyser? &#34;)) nb_mutations = 0 for i in range(1, nb_total + 1): reponse = int(input(f&#34;Échantillon {i} : sain (0) ou muté (1)? &#34;)) if reponse == 1: nb_mutations += 1 pourcentage = (nb_mutations / nb_total) * 100 print(f&#34;{nb_mutations}/{nb_total} échantillons sont mutés.&#34;) print(f&#34;Pourcentage de mutation : {pourcentage:.1f} %&#34;)</description>
    </item>
    <item>
      <title> Listes, chaines et visualisation des données</title>
      <link>/solutions_ateliers/6_listes_chaines_visualisation/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/solutions_ateliers/6_listes_chaines_visualisation/index.html</guid>
      <description>import matplotlib.pyplot as plt # Données temperatures = [ [15, 16, 14, 14, 17, 18, 19], # Ville A [22, 23, 21, 20, 24, 25, 26], # Ville B [5, 7, 6, 6, 8, 9, 7], # Ville C [10, 11, 12, 10, 13, 14, 15] # Ville D ] villes = [&#34;Ville A&#34;, &#34;Ville B&#34;, &#34;Ville C&#34;, &#34;Ville D&#34;] jours = [&#34;Lun&#34;, &#34;Mar&#34;, &#34;Mer&#34;, &#34;Jeu&#34;, &#34;Ven&#34;, &#34;Sam&#34;, &#34;Dim&#34;] # 1. Affichage des températures for i in range(len(villes)): print(villes[i], &#34;:&#34;, end=&#34; &#34;)&#x9;# end permet d&#39;ajouter un espace au lieu d&#39;un saut de ligne entre les villes for j in range(len(temperatures[i])): print(temperatures[i][j], end=&#34; &#34;) # end permet d&#39;ajouter un espace au lieu d&#39;un saut de ligne print() # retour à la ligne # 2. Min et max for i in range(len(villes)): tmax = max(temperatures[i]) tmin = min(temperatures[i]) print(f&#34;La température maximale de {villes[i]} est {tmax} °C&#34;) print(f&#34;La température minimale de {villes[i]} est {tmin} °C&#34;) # 3. Classification des températures for i in range(len(villes)): print() print(f&#34;Classification pour {villes[i]} :&#34;) for j in range(len(temperatures[i])): t = temperatures[i][j] if t &lt; 10: print(t, &#34;=&gt; Froide&#34;) elif 10 &lt;= t &lt;= 20: print(t, &#34;=&gt; Douce&#34;) else: print(t, &#34;=&gt; Chaud&#34;) # 4. Graphique for i in range(len(villes)): plt.plot(jours, temperatures[i], label=villes[i]) plt.title(&#34;Températures hebdomadaires&#34;) plt.xlabel(&#34;Jour&#34;) plt.ylabel(&#34;Température (°C)&#34;) plt.grid(True) plt.legend() plt.savefig(&#34;temperatures.png&#34;) plt.show()</description>
    </item>
    <item>
      <title> Dictionnaires</title>
      <link>/solutions_ateliers/7_dictionnaires/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/solutions_ateliers/7_dictionnaires/index.html</guid>
      <description>Exercice - Physique import matplotlib.pyplot as plt # 1. Constante gravitationnelle g = 9.8 # m/s² # 2. Création des dictionnaires vitesses = {} positions = {} # 3. Remplir les dictionnaires avec les formules physiques for t in range(6): # de 0 à 5 secondes vitesses[t] = g * t positions[t] = 0.5 * g * (t**2) # 4. Vérifier le contenu print(&#34;Vitesses :&#34;, vitesses) print(&#34;Positions :&#34;, positions) Résultat attendu :&#xA;Vitesses : {0: 0.0, 1: 9.8, 2: 19.6, 3: 29.4, 4: 39.2, 5: 49.0}&#xD;Positions : {0: 0.0, 1: 4.9, 2: 19.6, 3: 44.1, 4: 78.4, 5: 122.5} 5. Préparation des données pour les graphiques # Clés triées pour garantir l&#39;ordre temps = sorted(vitesses.keys()) # Extraction des valeurs à partir des clés triées valeurs_v = [vitesses[t] for t in temps] valeurs_y = [positions[t] for t in temps] (Remarque : on aurait aussi pu utiliser list(vitesses.values()) directement, mais ici on garantit que les deux listes suivent exactement le même ordre.)</description>
    </item>
    <item>
      <title> Tableaux NumPy et droite de régression</title>
      <link>/solutions_ateliers/8_numpy_regression/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/solutions_ateliers/8_numpy_regression/index.html</guid>
      <description>Exercice 1 import numpy as np import matplotlib.pyplot as plt # Données avec valeurs manquantes hauteurs = np.array([ [12.5, 13.1, 12.9, 13.0, 12.8], [11.2, 11.6, np.nan, 11.5, 11.3], [10.4, 10.1, 10.2, np.nan, np.nan] ]) conditions = [&#34;Naturelle&#34;, &#34;LED blanche&#34;, &#34;LED rouge&#34;] # Moyenne et écart-type en ignorant les données manquantes (NaN) moyennes = np.nanmean(hauteurs, axis=1) ecarts_type = np.nanstd(hauteurs, axis=1) # Affichage du résumé # Pour chaque hauteur: conditions; moyennes et écarts-type for i in range(3): print(f&#34;Moyenne ({conditions[i]}) = {moyennes[i]:.2f} cm, écart-type = {ecarts_type[i]:.2f} cm&#34;) # Identification de l&#39;indice de la plus grande hauteur moyenne indice_max = 0 # On suppose que le premier élément (indice 0) est le plus grand valeur_max = moyennes[0] # On suppose donc que la première hauteur est la plus grande # Boucle pour trouver la plus grande hauteur et son indice for i in range(1, len(moyennes)): if moyennes[i] &gt; valeur_max: valeur_max = moyennes[i] indice_max = i print(f&#34;Condition avec la plus grande croissance moyenne : {conditions[indice_max]}&#34;) # Graphique x = np.arange(len(conditions)) plt.figure(figsize=(8, 5))p # Traçage du graphique à barres et barres d&#39;erreur plt.bar(x, moyennes, yerr=ecarts_type, capsize=8, color=[&#34;green&#34;, &#34;gray&#34;, &#34;red&#34;]) plt.xticks(x, conditions) # pour afficher les conditions au lieu des valeurs, sur l&#39;axe x plt.ylabel(&#34;Hauteur moyenne (cm)&#34;) plt.title(&#34;Effet de la lumière sur la croissance des plantes&#34;) # Quadrillage horizontal seulement plt.grid(axis=&#34;y&#34;) # Pour que les paramètres (titre, étiquettes, graduations) # s&#39;intègre bien dans la zone de la figure plt.tight_layout() plt.savefig(&#34;graphique_croissance_lumiere.png&#34;) plt.show() Exercice 2 import numpy as np import matplotlib.pyplot as plt # Données expérimentales temps = np.array([0, 1, 2, 3, 4]) distance = np.array([0, 0.9, 1.8, 2.9, 4.1]) # Régression linéaire (degré 1 = droite) a, b = np.polyfit(temps, distance, 1) print(f&#34;Pente a = {a:.2f} m/s&#34;) print(f&#34;Ordonnée à l’origine b = {b:.2f} m&#34;) # Calcul des valeurs prédites par la droite distance_predite = a * temps + b # Calcul du coefficient de détermination R² distance_moy = np.mean(distance) ss_tot = np.sum((distance - distance_moy)**2) ss_res = np.sum((distance - distance_predite)**2) r2 = 1 - (ss_res / ss_tot) print(f&#34;Coefficient de détermination R² = {r2:.3f}&#34;) # Tracé du graphique (nuage de points) et de la droite plt.scatter(temps, distance, color=&#39;blue&#39;, label=&#39;Données expérimentales&#39;) plt.plot(temps, distance_predite, color=&#39;red&#39;, label=&#39;Droite de régression&#39;) plt.xlabel(&#34;Temps (s)&#34;) plt.ylabel(&#34;Distance (m)&#34;) plt.title(&#34;Mouvement rectiligne uniforme - Régression linéaire&#34;) plt.legend() plt.grid(True) plt.show() Interprétation scientifique :</description>
    </item>
    <item>
      <title> Lecture et écriture de fichiers de données</title>
      <link>/solutions_ateliers/9_fichiers/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/solutions_ateliers/9_fichiers/index.html</guid>
      <description>import numpy as np import pandas as pd # PARTIE 1 — Lecture et nettoyage avec pandas # Lecture du fichier CSV &#34;eau_riviere.csv&#34; df = pd.read_csv(&#34;eau_riviere.csv&#34;) print() print(&#34;Données initiales (pandas)&#34;) print(df) # Détection des valeurs manquantes print() print(&#34;Valeurs manquantes par colonne&#34;) print(df.isna().sum()) # Remplacement des valeurs manquantes par la moyenne de la colonne df[&#34;Temperature&#34;] = df[&#34;Temperature&#34;].fillna(df[&#34;Temperature&#34;].mean()) df[&#34;pH&#34;] = df[&#34;pH&#34;].fillna(df[&#34;pH&#34;].mean()) df[&#34;Oxygene&#34;] = df[&#34;Oxygene&#34;].fillna(df[&#34;Oxygene&#34;].mean()) # OU pour tout le DataFrame d’un coup # df = df.fillna(df.mean(numeric_only=True)) print() print(&#34;Données après remplissage des NaN&#34;) print(df) # Ajout de la colonne &#39;Qualite&#39; selon la concentration en oxygène # Règles : # - Oxygène &gt;= 8.0 → &#34;Bonne&#34; # - 7.5 &lt;= Oxygène &lt; 8.0 → &#34;Moyenne&#34; # - Oxygène &lt; 7.5 → &#34;Faible&#34; df[&#34;Qualite&#34;] = np.where( df[&#34;Oxygene&#34;] &gt;= 8.0, &#34;Bonne&#34;, np.where( (df[&#34;Oxygene&#34;] &gt;= 7.5) &amp; (df[&#34;Oxygene&#34;] &lt; 8.0), &#34;Moyenne&#34;, &#34;Faible&#34; ) ) # Ajout de la colonne &#39;Alerte&#39; selon le pH # Si pH &lt; 7.0 → &#34;Attention&#34;, sinon &#34;OK&#34; df[&#34;Alerte&#34;] = np.where(df[&#34;pH&#34;] &lt; 7.0, &#34;Attention&#34;, &#34;OK&#34;) print() print(&#34;Données finales avec colonnes dérivées&#34;) print(df) # Sauvegarde finale du fichier nettoyé df.to_csv(&#34;eau_riviere_nettoyee.csv&#34;, index=False) print() print(&#34;Fichier &#39;eau_riviere_nettoyee.csv&#39; sauvegardé avec succès.&#34;) # PARTIE 2 — Visualisation graphique (Optionnel) import matplotlib.pyplot as plt # Graphique 1 erreur = 0.2 couleurs = df[&#34;Qualite&#34;].map({&#34;Bonne&#34;: &#34;skyblue&#34;, &#34;Moyenne&#34;: &#34;gold&#34;, &#34;Faible&#34;: &#34;salmon&#34;}) plt.bar(df[&#34;Site&#34;], df[&#34;Oxygene&#34;], yerr=erreur, capsize=5, color=couleurs) plt.title(&#34;Concentration en oxygène dissous dans la rivière&#34;) plt.xlabel(&#34;Site d&#39;échantillonnage&#34;) plt.ylabel(&#34;Oxygène (mg/L)&#34;) plt.grid(axis=&#34;y&#34;, linestyle=&#34;--&#34;, alpha=0.7) plt.show() # Graphique 2 plt.scatter(df[&#34;Site&#34;], df[&#34;Oxygene&#34;]) plt.title(&#34;Concentration en oxygène dissous dans la rivière&#34;) plt.xlabel(&#34;Site d&#39;échantillonnage&#34;) plt.ylabel(&#34;Oxygène (mg/L)&#34;) plt.grid() plt.show() Que fait .map() en pandas ? La méthode .map() permet de remplacer les valeurs d’une série selon un dictionnaire de correspondance. Elle prend chaque valeur d’une colonne et la transforme selon les règles définies.</description>
    </item>
    <item>
      <title> Fonctions personnalisées</title>
      <link>/solutions_ateliers/11_fonctions_perso/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/solutions_ateliers/11_fonctions_perso/index.html</guid>
      <description>Exercice : Calcul de dilution (C₁V₁ = C₂V₂) def lire_donnees(): &#34;&#34;&#34; Lit les données nécessaires au calcul d’une dilution. Cette fonction demande à l’utilisateur : - la concentration de la solution mère (C1, en mol/L), - la concentration finale souhaitée (C2, en mol/L), - le volume final de la solution (V2, en L). Returns: tuple: Un triplet (C1, C2, V2) contenant les valeurs saisies par l’utilisateur. Exemple : &gt;&gt;&gt; C1, C2, V2 = lire_donnees() --- Programme de dilution --- Concentration de la solution mère (mol/L) : 1.0 Concentration finale souhaitée (mol/L) : 0.2 Volume final de la solution (L) : 0.5 # Retourne (1.0, 0.2, 0.5) &#34;&#34;&#34; print(&#34;--- Programme de dilution ---&#34;) C1 = float(input(&#34;Concentration de la solution mère (mol/L) : &#34;)) C2 = float(input(&#34;Concentration finale souhaitée (mol/L) : &#34;)) V2 = float(input(&#34;Volume final de la solution (L) : &#34;)) return C1, C2, V2 def calculer_v1(C1, C2, V2): &#34;&#34;&#34; Calcule le volume de solution mère à prélever pour réaliser une dilution. Utilise la formule : V1 = (C2 × V2) / C1 Args: C1 (float): Concentration de la solution mère (mol/L). C2 (float): Concentration finale souhaitée (mol/L). V2 (float): Volume final de la solution (L). Returns: float: Le volume de solution mère à prélever (V1, en L). Exemple : &gt;&gt;&gt; calculer_v1(1.0, 0.2, 0.5) 0.1 &#34;&#34;&#34; V1 = (C2 * V2) / C1 return V1 def afficher_resultat(V1): &#34;&#34;&#34; Affiche le volume de solution mère à prélever. La valeur est arrondie à deux décimales pour plus de clarté. Args: V1 (float): Volume calculé de solution mère à prélever (en L). Affiche : Un message indiquant le volume nécessaire pour préparer la solution diluée. Exemple : &gt;&gt;&gt; afficher_resultat(0.1) Il faut prélever 0.1 L de solution mère pour préparer la solution diluée. &#34;&#34;&#34; V1_arrondi = round(V1, 2) print(f&#34;Il faut prélever {V1_arrondi} L de solution mère pour préparer la solution diluée.&#34;) # Programme principal # Étape 1 : Lire les données C1, C2, V2 = lire_donnees() # Étape 2 : Calculer le volume à prélever V1 = calculer_v1(C1, C2, V2) # Étape 3 : Afficher le résultat afficher_resultat(V1) Exemple de sortie (si l’utilisateur entre 2.0, 0.5, 1.0) : --- Programme de dilution ---&#xD;Concentration de la solution mère (mol/L) : 2.0&#xD;Concentration finale souhaitée (mol/L) : 0.5&#xD;Volume final de la solution (L) : 1.0&#xD;Il faut prélever 0.25 L de solution mère pour préparer la solution diluée.</description>
    </item>
  </channel>
</rss>