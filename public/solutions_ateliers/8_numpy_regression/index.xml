<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title> Tableaux NumPy et droite de régression :: 420-SN1-RE</title>
    <link>https://example.org/solutions_ateliers/8_numpy_regression/index.html</link>
    <description>Exercice 1 import numpy as np import matplotlib.pyplot as plt # Données avec valeurs manquantes hauteurs = np.array([ [12.5, 13.1, 12.9, 13.0, 12.8], [11.2, 11.6, np.nan, 11.5, 11.3], [10.4, 10.1, 10.2, np.nan, np.nan] ]) conditions = [&#34;Naturelle&#34;, &#34;LED blanche&#34;, &#34;LED rouge&#34;] # Moyenne et écart-type en ignorant les données manquantes (NaN) moyennes = np.nanmean(hauteurs, axis=1) ecarts_type = np.nanstd(hauteurs, axis=1) # Affichage du résumé # Pour chaque hauteur: conditions; moyennes et écarts-type for i in range(3): print(f&#34;Moyenne ({conditions[i]}) = {moyennes[i]:.2f} cm, écart-type = {ecarts_type[i]:.2f} cm&#34;) # Identification de l&#39;indice de la plus grande hauteur moyenne indice_max = 0 # On suppose que le premier élément (indice 0) est le plus grand valeur_max = moyennes[0] # On suppose donc que la première hauteur est la plus grande # Boucle pour trouver la plus grande hauteur et son indice for i in range(1, len(moyennes)): if moyennes[i] &gt; valeur_max: valeur_max = moyennes[i] indice_max = i print(f&#34;Condition avec la plus grande croissance moyenne : {conditions[indice_max]}&#34;) # Graphique x = np.arange(len(conditions)) plt.figure(figsize=(8, 5))p # Traçage du graphique à barres et barres d&#39;erreur plt.bar(x, moyennes, yerr=ecarts_type, capsize=8, color=[&#34;green&#34;, &#34;gray&#34;, &#34;red&#34;]) plt.xticks(x, conditions) # pour afficher les conditions au lieu des valeurs, sur l&#39;axe x plt.ylabel(&#34;Hauteur moyenne (cm)&#34;) plt.title(&#34;Effet de la lumière sur la croissance des plantes&#34;) # Quadrillage horizontal seulement plt.grid(axis=&#34;y&#34;) # Pour que les paramètres (titre, étiquettes, graduations) # s&#39;intègre bien dans la zone de la figure plt.tight_layout() plt.savefig(&#34;graphique_croissance_lumiere.png&#34;) plt.show()&#xD;Exercice 2 import numpy as np import matplotlib.pyplot as plt # Données expérimentales temps = np.array([0, 1, 2, 3, 4]) distance = np.array([0, 0.9, 1.8, 2.9, 4.1]) # Régression linéaire (degré 1 = droite) a, b = np.polyfit(temps, distance, 1) print(f&#34;Pente a = {a:.2f} m/s&#34;) print(f&#34;Ordonnée à l’origine b = {b:.2f} m&#34;) # Calcul des valeurs prédites par la droite distance_predite = a * temps + b # Calcul du coefficient de détermination R² distance_moy = np.mean(distance) ss_tot = np.sum((distance - distance_moy)**2) ss_res = np.sum((distance - distance_predite)**2) r2 = 1 - (ss_res / ss_tot) print(f&#34;Coefficient de détermination R² = {r2:.3f}&#34;) # Tracé du graphique (nuage de points) et de la droite plt.scatter(temps, distance, color=&#39;blue&#39;, label=&#39;Données expérimentales&#39;) plt.plot(temps, distance_predite, color=&#39;red&#39;, label=&#39;Droite de régression&#39;) plt.xlabel(&#34;Temps (s)&#34;) plt.ylabel(&#34;Distance (m)&#34;) plt.title(&#34;Mouvement rectiligne uniforme - Régression linéaire&#34;) plt.legend() plt.grid(True) plt.show()&#xD;Interprétation scientifique :</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <atom:link href="https://example.org/solutions_ateliers/8_numpy_regression/index.xml" rel="self" type="application/rss+xml" />
  </channel>
</rss>